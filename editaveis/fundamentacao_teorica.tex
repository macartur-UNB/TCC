\part{Fundamentação Teórica}

\chapter[Fundamentação Teórica]{Fundamentação Teórica}

\section{Linguagens compiladas vs interpretadas}

Uma linguagem de programação é um método padronizado que possui
 um conjunto de instruções para realizar a comunicação entre o homem
 e o computador \cite{ref1} , através de um conjunto de regras
 definidas sintaticamente e sematicamente \cite{ref2}.
 Com uma linguagem
 de programação é possível especificar precisamente um conjunto de regras
 sobre  as quais dados serão armazenados ou transmitidos e criar algoritmos
 que facilitem operações ou resolvam problemas.
    
Para que um algoritmo escrito em uma linguagem de programação seja executado 
por um computador é necessário a criação de um arquivo de texto contendo um 
conjunto de palavras ou símbolos escritas de forma ordenada  e de maneira 
lógica \cite{ref3}. Este arquivo é chamado de código fonte.
    
Antes da execução, a linguagem de programação escrita no código fonte deve
 ser convertida (através do processo de compilação), traduzida (através do 
processo de interpretação) ou convertida e traduzida (forma hibrida) em um 
código de máquina \cite{ref4}.

\subsection{Compilação}

No processo de compilação a linguagem de programação contida no código fonte
 deve ser transformada em uma linguagem de máquina, a qual será posteriormente
 executada pelo processador \cite{ref2}. 

O processo de compilação requer a utilização de um compilador, o qual consiste
 em um programa ou conjunto de programas  que tem como entrada o código fonte 
escrito em uma linguagem de programação e cria um programa sematicamente 
equivalente uma outra linguagem, chamado de código objeto \cite{ref4}.

Após a compilação, a execução do código objeto criado a partir do algoritmo do
 código fonte de entrada é requisitado pelo usuário para que o processador 
execute as instruções de máquina \cite{ref6}.

As linguagens que, em geral, são compiladas, lideram em performance em relação
 as linguagens que, em geral, são interpretadas. Isso porque as decisões que são
 tomadas em tempo de compilação não são necessários no tempo de execução \cite{ref7}.
Por exemplo, se um compilador garantir que uma variável x seja sempre alocada 
em uma  mesma posição na memória,  ele pode gerar instruções de maquina que 
acesse esta localização sempre que se referenciar a variável x. 
Por outro lado, um interpretador precisa procurar  por x em uma tabela a cada 
acesso, a fim de achar sua localização \cite{ref8}.

\begin{description}
    \item[Exemplos de Linguagem que, em geral,são compilada:]\
    \begin{itemize}
      \item  Ada
      \item  ALGOL
      \item  BASIC
      \item  C
      \item  C++
      \item  COBOL
      \item  Cobra
      \item  Common Lisp
      \item  D
      \item  Delphi
      \item  Eiffel
      \item  Fortran
      \item  Objective-C
      \item  Pascal
      \item  Visual Basic
      \item  Visual Prolog
    \end{itemize}
\end{description}

\subsection{Interpretação}

No processo de interpretação, o código fonte é passado para um programa chamado
 interpretador, o qual é responsável pela leitura do código e pela tradução, 
em tempo real, deste código em instruções a serem executadas pelo sistema 
operacional ou  pelo processador \cite{ref8}. No caso de linguagens que são, em geral, 
interpretadas, costuma-se nomear os códigos-fonte como scripts, embora não seja 
uma regra geral.

Ao contrário do compilador, o interpretador faz a leitura do código fonte e 
executa  as respectivas instruções em tempo real. Isso faz com que  códigos 
interpretados tenham maior flexibilidade e um melhor diagnóstico (exibição de 
mensagens de erros) do que  códigos compilados. A interpretação também pode lidar 
melhor com linguagens de programação nas quais características fundamentais, 
tais como  o tamanho e  o tipo das variáveis, podem depender dos dados de 
entrada \cite{ref6}.

Sem  o recurso da interpretação, seria uma tarefa deveras complexa implementar 
alguns recursos  presentes em linguagens Lisp e Prolog onde, por exemplo, 
um programa pode escrever novas peças de si mesmo e executá-las em tempo real
 \cite{ref6}.

\begin{description}
    \item[Exemplos de Linguagem que, em geral, são interpretadas:]\
    \begin{itemize}
        \item ActionScript
        \item APL
        \item ASP
        \item BASIC
        \item C\#
        \item CYBOL
        \item Java
        \item JavaScript
        \item Lisp
        \item Logo
        \item Lua
        \item PHP
        \item Python
        \item Ruby
        \item Scheme
        \item Smalltalk
        \item VBScript
    \end{itemize}
\end{description}

\subsection{VM}

Para algumas linguagens existe o caso em que o compilador tem o papel
 de converter o código fonte em um \textit{byte code}\cite{ref9}. 
O \textit{byte code}
é uma linguagem de baixo nível  similar a linguagem de máquina, que 
deve ser interpretada por um outro programa chamado Maquina Virtual. 

Esta estratégia mista de pré-compilar o código para uma linguagem 
intermediária e interpretá-la em uma máquina virtual é denominada 
estratégia hídriba. 

\begin{description}
    \item[Exemplos de linguagens que utilizam, em geral, 
          a estratégia híbrida, são:]\
    \begin{itemize}
        \item Java  
        \item Python
        \item JRuby
        \item Oxygene
        \item Rhino
        \item Nashorn
        \item JGNAT
        \item Jython
        \item Rakudo Perl 6
    \end{itemize}
\end{description}

\subsection{JIT}

O termo \textit{Just In Time} - JIT - veio de um novo modelo de  negócio da
 indústria manufatureira : uma estratégia de negócio onde a produção 
ou compra era feita sobre demanda, ao invés da utilização de estoques
 \cite{ref10}. 
Este modelo tem como vantagens menores custos com armazenamento, 
menos desperdícios, resposta mais rápida aos clientes e maior 
produção potencial.

Na compilação, esta analogia se adapta bem por que um compilador JIT 
não armazena os binários do programa no disco (o estoque), mas começa 
a compilação apenas de partes do programa necessárias durante a execução
 \cite{ref11}.

Foram desenvolvidas, principalmente para linguagens que são, em geral, 
interpretadas, ferramentas que se valem do JIT para acelerar a interpretação
 e execução dos códigos-fonte (scripts) como, 
por exemplo, o PyPy para a linguagem Python.\footnote{http://pypy.org/}


\section{Compilação}

\subsection{Pré-processadores}


Antes de um código-fonte passar pelo processo de compilação, pode ser
 necessária a execução de um programa, denominado pré-processador, que
 tem como responsabilidade preparar o código-fonte para a compilação. 

Dentre as possíveis tarefas e caracerísticas comuns a um pré-processador,
 podemos citar:

\begin{itemize}

\item \textit{Processamento de macros}: um pré-processador pode permitir que um usuário 
    defina macros que sejam abreviações para construções mais longas\cite{ref11};

\item \textit{Inclusão de arquivos}: um pré-processador pode incluir arquivos cabeçalho no
     texto do programa. Por exemplo, o pré-processador faz com que o conteúdo de
     um arquivo externo seja transcrito no código-fonte no ponto onde existe a 
    marcação para sua inclusão\cite{ref11};

\item \textit{Pré-processadores “racionais”}: este tipo de pré-processador é responsável 
    por permitir a construção de macros utilizando condicionais while ou if mesmo
     em linguagens que não suportem tais estruturas\cite{ref11};

\item \textit{Extensões de linguagens}: são formas de conferir maior poder as linguagens
     através de macros embutidas. Por exemplo, 
    Equel \footnote{Equel:  http://www.eecs.berkeley.edu/~wong/wong\_pubs/wong46.pdf
     acessado 11/junho p.6} é uma linguagem de 
    interrogação embutida em C que permite a manipulação de banco de dados. 
    Os enunciados começados com \#\# são considerados pelo pré-processador como
     comandos de acesso ao banco de dados, os quais não fazem parte da 
    linguagem C e, quando traduzidos, são convertidos em rotinas que tratam 
    este acesso ao banco de dados\cite{ref11}.

\end{itemize}

\subsection{Compilação}

No processo de compilação tradicional, o compilador atua em duas fases 
principais: análise e síntase\cite{ref12}\cite{ref13}. A Figura \ref{fig01}
 ilustra estas fases. 

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.5]{figuras/fases_da_compilacao.eps}
    \caption{Fases da Compilação, (Scott, Michael L.,2008)  com adaptações.}
    \label{fig01}
\end{figure}

A fase de analise (ou \textit{front-end}) de um compilador é a fase que 
tem como objetivo entender o código fonte e  representá-lo em uma 
estrutura intermediária que facilite sua manipulação posterior. 
Esta fase é subdividida em analise léxica, analise sintática, 
analise semântica e geração de código intermediário \cite{ref14}.

A fase de síntese (ou \textit{back-end}) de um compilador é a fase que tem 
como objetivo realizar a geração de código final otimizando o código 
analisado na fase de sintase, gerando um código sematicamente igual ao 
código fonte e com melhorias de performance e espaço. Esta fase é 
subdividida em otimização de código independente do alvo, geração de 
código alvo, otimização de código  para o alvo específico \cite{ref14}.


\subsection{Analise Léxica}
    
A analise léxica é a primeira fase a ser executada pelo compilador \cite{ref15}. 
A função do analisador léxico, também denominado scanner, é ler o código fonte, 
caracter a caracter, buscando a separação e  a identificação dos elementos do 
programa, denominados símbolos léxicos ou tokens \cite{ref16}. Assim, é 
produzida uma sequência de tokens que será utilizada na análise sintática \cite{ref17}. 

Esta fase também tem a importância de realizar a remoção de elementos 
“decorativos” do programa, tais como espaços, tabulações, caracteres de 
avanço e comentários \cite{ref15}. Para auxiliar a construção deste analisador,
 estão disponíveis uma série de geradores automáticos de analisadores léxicos, 
cujo objetivo é reduzir o esforço de programação deste tipo de ferramenta, 
especificando-se apenas os tokens a serem reconhecidos \cite{ref18}.

\subsection{Analise Sintática}

A analise sintática, ou analise gramatical, é o processo de se determinar 
se uma cadeia de símbolos léxicos pode ser gerada por uma gramática pré-definida
 \cite{ref19}. O analisador sintático é o responsável por verificar se os 
símbolos contidos no código fonte formam um programa válido ou não \cite{ref20}.

A maioria dos métodos de analise sintática são de dois tipos, denominados 
\textit{top-down} ou \textit{bottom-up} \cite{ref21}. Como indicado por 
seus nomes, os analisadores sintáticos \textit{top-down} constroem árvores 
do topo para as folhas, enquanto o analisadores \textit{bottom-up} começam das 
folhas e constroem a árvore de baixo para cima até chegar na raiz. Em ambos os
 casos  estas árvores  elas são percorridas da esquerda para a direita, 
simbolo a simbolo. Estes dois tipos são utilizados devido seu potencial 
expressivo para descrever a maioria das construções sintáticas das linguagens 
de programação \cite{ref20}. Para auxiliar na criação de analisadores sintáticos 
existem disponíveis uma série de geradores automáticos, como por exemplo, 
o \textit{Flex} 
\footnote{Flex: encontrado em http://dinosaur.compilertools.net/ acessado dia 
20/06/2015}, 
o \textit{Bison} 
\footnote{Bison: econtrado em http://www.gnu.org/software/bison/ acessdo dia 
20/06/2015}
 e o \textit{JavaCC} 
\footnote{JavaCC: encontrado em https://javacc.java.net/ acessado dia 20/06/2015}
 \cite{ref22}.

\subsection{Analise Semântica}

O analisador semântico tem como função prover métodos para que as estruturas 
construídas pelo analisador sintático possam ser avaliadas ou executadas \cite{ref23}. 
Estas validações são feitas para assegurar que certos tipos de erros de 
programação sejam detectados e reportados. Os  exemplos de verificação incluem 
declaração de tipo, declaração de funções, sobrecarga de funções, sobrecarga de 
operadores, verificação de fluxo de controle, verificação de operações logicas e 
aritméticas válidas entre variáveis e a verificação de unicidade de variáveis em 
determinados escopos da linguagem \cite{ref24}.

\subsection{Gerador de Código Intermediário}

Após produzir uma árvore sintática sematicamente correta, o compilador é capaz de
 produzir uma linguagem de representação intermediária do código fonte. Uma linguagem 
intermediária está mais próxima de uma linguagem de objeto do que do código fonte. 
No entanto, a linguagem  intermediária permite uma manipulação mais fácil do que o 
código de maquina ou o \textit{Assembly} \cite{ref25}. 

Um tipo bem conhecido de linguagem intermediara é o código (ou sentença) de três 
endereços\cite{ref26}. Este código é uma sequência de enunciados na forma geral, apresentada 
 no Código \ref{codigo01}.


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
								Código de três endereços},
											label=codigo01]
   x:=y op z
\end{lstlisting}


onde \textbf{x}, \textbf{y}, \textbf{z} são nomes, constantes ou objetos de dados 
temporários criados pelo compilador e \textbf{op} representa um operador qualquer,
 tal como um operador de ponto fixo, flutuante ou um operador lógico sobre dados
 booleanos \cite{ref27}. Uma forma prática de representar sentenças de três endereços é o uso
 de quádrupla (operador, argumento 1, argumento 2 e resultado). 
Este esquema de representação de código intermediário é o preferido por diversos
 compiladores, principalmente por aqueles que executam extensivas otimizações de
 código, uma vez que o código intermediário pode ser manipulado mais 
facilmente \cite{ref28}. Além destas representações existem outras como as 
árvores, grafos acíclicos dirigidos (DAG) e a notação polonesa \cite{ref29}.

Para garantir que um código tenha o seu desempenho ampliado e utilize menos 
espaço em disco, a fase de otimização de código busca examinar 
estrategicamente o código intermediário produzido na fase anterior e, com o 
uso de técnicas de otimização, produzir um código mais eficiente \cite{ref30}
. A otimização de código pode ocorrer em duas etapas: uma após a geração de 
código intermediário e a outra depois da geração do código para a máquina 
alvo \cite{ref31}. 
Para a execução desta etapa são utilizadas técnicas para detectar 
padrões dentro de um código produzido e substituí-los por códigos mais
 eficientes \cite{ref28}. Entre as técnicas usadas realizadas estão a 
substituição de expressões que podem ser calculadas durante o tempo 
de compilação, movimentação de código, eliminação de sub-expressões 
redundantes, desmembramento de laços, eliminação de variáveis de indução, 
substituição de multiplicação pelo \textit{shift} binário, redução da 
quantidade de laços, entre outras \cite{ref30}.

\subsection{Geração de Código}

Gerador de código é a parte ou componente do compilador responsável por 
realizar a o mapeamento da linguagem intermediária otimizada para a linguagem 
alvo. Caso a linguagem alvo seja um código de máquina,  registradores ou 
localização de memoria são selecionados para armazenar valores das 
variáveis usadas no programa. Então, o código intermediário é traduzido em 
sequência para instruções de máquina que realizarão as operações \cite{ref32}.
Mesmo que o código traduzido seja otimizado, após a tradução para a 
linguagem alvo é  possível que novas otimizações possam ser feitas, de modo 
que é possível a otimização especifica apresentada nas Figura \ref{fig02}.

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.7]{figuras/otimizacao_especifica.eps}
    \caption{Exemplos de Otiminizações especificas,
             (Scott, Michael L.,2009) com adaptações }
    \label{fig02}
\end{figure}


\subsection{Assembly}

Segundo Michael L. Scott, um código de máquina é uma sequência de bits que
 corresponde a uma instrução executada por um processador, realizando 
operações de adições, comparações, movimento de informação de uma localização
 da memória, entre outros. Detalhar instruções de máquina a nível de bits é 
uma tarefa trabalhosa \cite{ref34}. 

Um programa capaz de realizar o cálculo do máximo divisor comum através do 
algoritmo de Euclides estendido pode ser representado  em código de máquina 
usando notação hexadecimal para a representação dos bits, conforme apresentado
 no Código \ref{codigo_02} \cite{ref34}.


\begin{lstlisting}[language=Pascal,frame=single,captionpos=b,
												caption={Algoritmo de 
									   Euclides estendido representado 
									   em código de máquina,com adaptações},
                                                            label=codigo_02]
 55 89 e5 53  83 ec 04 83  e4 f0 e8 31  00 00 00 89  c3 e8 a2 00
 00 00 39 c3  74 10 8d b6  00 00 00 00  39 c3 7e 13  29 c3 39 c3
 75 f6 89 c1  24 e8 6e 00  00 00 8b 5d  fc c9 c3 29  d8 eb eb 90
\end{lstlisting}

Para facilitar a comunicação entre uma linguagem composta apenas por bits e 
uma linguagem entendida por um desenvolvedor foi necessário a criação de uma
 linguagem que permitisse que as operações em bits fossem representadas por 
abreviações ou símbolos que facilitassem o entendimento por parte do programador.
 Assembly é a linguagem escolhida para estas representações, onde cada 
instrução do processador foi mapeada em um mnemônico, representados geralmente 
por acrônimos do inglês (por exemplo, ‘mov’ representa ‘mover’, ‘rep’ 
representa repetição e assim por diante)\cite{ref34}.

O mesmo programa mostrado no Código \ref{codigo_02} pode ser representado 
em assembly, conforme ilustrado no Código \ref{codigo_03} \cite{ref34}. 

\begin{lstlisting}[language=Pascal,frame=single,captionpos=b,caption={Algoritmo de 
                Euclides estendido representado em Assembly, com adaptações},
                                                            label=codigo_03]
    pushl %ebp              jle   D
    mov   %esp, %ebp        subl  %eax, %ebx
    pushl %ebx           B: cmpl  %eax, %ebx   
    subl  $4, %esp          jne   A
    andl  $-16, %esp     C: call  %ebx, (%esp)
    call  getint            call  putint
    movl  %eax, %ebx        movl  -4(%ebp), %ebx
    call  getint            leave
    cmpl  %eax, %ebx        ret
    je    C              D: subl  %eax, %eax
 A: cmpl  %eax, %ebx        jmp   B

\end{lstlisting}

Para converter um programa de assembly para um código de maquina é necessário
 um montador, denominado Assembler. O montador é um programa que realiza a 
parametrização das instruções da linguagem Assembly para os bits 
correspondentes da linguagem de máquina (também chamado de opcode)\cite{ref35}.

\subsection{Linking}


\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.6]{figuras/ligador.eps}
    \caption{Representação da ligação entre objetos,(Levine,
											    John R.,2000),com adaptações.}
    \label{fig03}
\end{figure}

Um compilador é capaz de realizar a compilação de partes de programas e gerar
 objetos que podem ser combinados para formar um programa executável. 
\textit{Linker} (ou Ligador) é um programa capaz de realizar a junção 
de objetos gerados por um compilador, ligando nomes mais abstratos em nomes
 mais concretos, permitindo o desenvolvedor escrever códigos usando nomes 
mais abstratos \cite{ref36}.


 Basicamente o Linker liga um nome ou simbolo escrito por um desenvolvedor e
 referencia a localização do inicio do código que possui a função ou o dado
 estático. Como no exemplo descrito por John Levine, o linker pega um 
referência escrita como “getline”  e vincula a “uma localização de 612 bytes 
no inicio de um código executável do modulo iosys” \cite{ref36}. 

A fase de linkedição existem dois passos. No primeiro o Linker recebe como 
entrada um conjunto de arquivos objetos, bibliotecas e parâmetros e produz
 como resultado um arquivo de saída, como mostrado na Figura \ref{fig03}
 \cite{ref37}. Neste passo é criada uma tabela com 
todos os segmentos definidos nos arquivos fontes e uma tabela de símbolos 
importados ou exportados. Depois o Linker atribui uma localização numérica 
para cada símbolo, determinando o tamanho e a localização dos segmentos no
 espaço de endereço final. O segundo passo usa as informações do primeiro
 para controlar a linkedição, ajustando os endereços de memória do código e
 escrevendo os endereços de código realocado no arquivo de saída
 (programa executável).


\subsection{Bibliotecas}

Com o passar do tempo utilizando compiladores e linkers, muitos 
desenvolvedores perceberam que poderiam economizar tempo e esforço 
reutilizando pedaços de códigos escritos em outros programas. Para evitar a
 cópia de arquivos entre projetos surgiram as chamadas bibliotecas \cite{ref38}.

Biblioteca é um conjunto de códigos compilados que podem ser incorporados a
 um ou mais de um projetos, como mostrado nas Figura \ref{fig04}, e figura
 \ref{fig05}. A organização de códigos em bibliotecas permite que 
programas sejam mais modulares, mais rápidos de recompilar e mais 
fáceis de manter\cite{Lasca}.

As bibliotecas podem ser divididas em três tipos: estáticas, 
dinâmicas e compartilhadas\cite{Lasca}.

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.45]{figuras/reuso_lib_estatica.eps}
    \caption{ Representação de reuso com biblioteca estática,(Milan Stevanovic),com adaptações.}
    \label{fig04}
\end{figure}

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.45]{figuras/reuso_lib_estatica2.eps}
    \caption{Representação de reuso (maneira trivial),(Milan Stevanovic),com adaptações.}
    \label{fig05}
\end{figure}


\subsection{Bibliotecas Estáticas}

Bibliotecas estáticas (que normalmente  são nomeadas com o  sufixo ‘.a’) 
são módulos de programas compilados separadamente, que podem ser utilizados
 na construção de um programa executável. Assim, após a etapa de compilação de
 um projeto, o linker faz a ligação entre as bibliotecas estáticas como
 mostrado na Figura \ref{fig04} \cite{ref39}.

Estas bibliotecas são mais difíceis de se manter, pois a cada atualização de uma
 biblioteca estática todos os projetos dependentes da mesma devem ser recompilados.
 Outra dificuldade é que um o binário final do projeto fica maior em relação aos
 outros tipos de bibliotecas (pois ele incorpora uma cópia de cada biblioteca
 estática utilizada) e pode conter informações que não são utilizadas no projeto.
 Bibliotecas estáticas, por estes motivos, não são utilizadas com tanta
 frequência nos dias de hoje.


\subsection{Bibliotecas Dinâmicas}

Ao contrário das bibliotecas estáticas, as bibliotecas dinâmicas são códigos
 objetos que podem ser carregados durante a execução de um projeto, como
 representado na figura \ref{fig06} \cite{ref41}. Bibliotecas dinâmicas 
não aumentam o tamanho do código binário do projeto final mas, no entanto,
 a execução do projeto necessita da utilização de um arquivo externo
 (normalmente nomeado com o sufixo ‘.so’ ou ‘.dll’), que contém as
 informações a serem carregadas\cite{Lasca2}. Em ambiente Linux as
 bibliotecas devem ser  registradas em uma variável de ambiente chamada
 LD\_LIBRARY\_PATH, que possui o caminho de todas as bibliotecas dinâmicas
 que podem ser utilizadas.

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.5]{figuras/dynamic_lib.eps}
    \caption{Representação de biblioteca dinâmica,(Milan Stevanovic) com adaptações.}
    \label{fig06}
\end{figure}


\section{Métodos para a redução do tempo de compilação}

\subsection{Include Guards}\label{include_guards_section}

Em C++ a inclusão de um arquivo de código fonte em outro arquivo fonte é feita
 através da diretiva de pré-processamente chamada \texttt{include}, que pode 
ser utilizada como mostrado no Codigo \ref{codigo_04}. 

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={Diretiva de 
                           pré-processamento para inclusão de um arquivo},
                                                   label=codigo_04]
// biblioteca de sistema 
#include <nome do arquivo>  

ou

// outras bibliotecas 
#include "nome do arquivo"  

\end{lstlisting}


Diretivas \texttt{include} normalmente são utilizadas várias vezes em um projeto.
 No entanto, o pré-processador não é capaz de verificar se um arquivo já foi
 adicionado, o que pode ocasionar um erro de duplicação de definição de
 estruturas e elementos do código. Um exemplo deste problema é mostrado na
 Figura \ref{fig07} \cite{ref41}.

\begin{figure}[h]
    \centering
        \includegraphics[keepaspectratio=true,scale=0.6]{figuras/multi_include.eps}
    \caption{ Representação de includes redundante,(John Lakos,1996) com adaptações.}
    \label{fig07}
\end{figure}

Para correção deste problema foram criadas as guardas de inclusão 
(no inglês chamada de  \textit{include guards} ou \textit{guard conditions}),
 que são diretivas de pré-processamento utilizada para verificar se um
 identificador já está definido ou não. Existem varias versões de guardas
 de inclusão, as quais serão citadas adiante\cite{ref42}.

Normalmente, arquivos-cabeçalho (ou \textit{headers}) são utilizados para
 declarações de estruturas, variáveis, funções e macros. Tais arquivos são
 identificados pelos sufixo ‘.h’,’.hpp’,’.hxx’ ou ‘.hpp’. As implementações
 das funções e definições de variáveis são feitas, na maioria das vezes, em
 arquivos denominados fontes (ou \textit{sources}), cujas extensões mais
 comuns são ".c", ".cpp", ".cxx", ".cc", ".c++", entre outros
 \cite{gcc-sufix}.

Há quatro tipos de guardas de inclusão:

\begin{enumerate}
\item Interna ao arquivo \textit{header}:

A diretiva "\#ifndef" é utilizada para verificar se um identificador foi 
 definido (forma negativa, para a forma positiva a diretiva é "\#ifdef"); a 
diretiva "\#define" é utilizada para definir um identificador; e a diretiva 
"\#endif" e utilizada para finalizar  uma condição (diretivas "\#ifdef" e 
"\#ifndef") \cite{ref42}.

Caso o identificador já esteja definido, o pré-processador irá ignorar 
qualquer informação que que esteja entre as diretivas "\#ifndef"  e "\#endif";
 caso não esteja definido, o identificador serão então definido e as informações
 que seguem a diretiva serão incluídas no arquivo resultante\cite{ref42}.

Os Códigos \ref{codigo_004}, \ref{codigo_05} e \ref{codigo_06} ilustram uma 
guarda de inclusão interna ao arquivo \textit{header}.

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
									Arquivo c.hpp contendo guardas
													 de inclusão interna},
                                                            label=codigo_004]
// c.h  declaracao de variavel
// verficar se o simbolo INCLUDE_C esta definido
#ifndef INCLUDE_C   
// define um simbolo INCLUDE_C
#define INCLUDE_C   

#include "a.hpp"      // importa o arquivo "a.hpp"
#include "b.hpp"      // importa o arquivo "b.hpp"

...                 // define as estruturas

#endif              // fim da condicional "#ifndef" 
\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                                     Arquivo b.hpp que inclue o arquivo a.h},
                                                            label=codigo_05]
// b.hpp
#ifndef INCLUDE_B
#define INCLUDE_C
 #include "a.hpp"
 // declaracao de estruturas 
 ...
#endif    
\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={Arquivo a.hpp 
                                    contendo guardas de inclusão interna},
                                                            label=codigo_06]
// a.hpp    arquivo de declaracao
#ifndef INCLUDE_A
#define INCLUDE_A
  // declaracao de estruturas 
  ...
#endif
\end{lstlisting}


\item Externa ao arquivo de \textit{header}:
 
Na  guarda de condição externa  são utilizadas as mesmas diretivas da interna,
 sendo a única diferença é a localização das diretivas: elas antecederão o uso
 da diretiva \#\texttt{include}. Um exemplo da utilização de guarda de condição 
externa é mostrado nos Código \ref{codigo_07},\ref{codigo_08} e
 \ref{codigo_09}\cite{ref42}.


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
									Arquivo c.hpp 
                                    contendo guardas de inclusão externa},
                                                            label=codigo_07]
// c.hpp arquivo de declaracao de estruturas de c

#ifndef INCLUDE_A
#define INCLUDE_A
/* inclue o arquivo a.hpp caso o simbolo 
   INCLUDE_A nao esteja definido */
#include "a.hpp"
#endif
        
#ifndef INCLUDE_B
#define INCLUDE_B
 /* inclue o arquivo b.hpp caso o simbolo 
    INCLUDE_B nao esteja definido */
 #include "b.hpp"
#endif

 ... //implementa as declaracoes

\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
										   Arquivo a.hpp 
                                           com guarda de inclusão externa},
                                                            label=codigo_08]
// a.hpp         declaracao das estruturas de a.hpp

...

\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
										   Arquivo b.hpp
                                           com guarda de inclusão externa},
                                                            label=codigo_09]
//b.hpp        declaracao das estruturas de b.hpp

...

\end{lstlisting}


\item Redundância:\label{redundancia_melhor}

Consiste em utilizar, simultaneamente, as guardas de inclusão internas e 
externas. 

Segundo John Lakos, está guarda de inclusão é a mais trabalhosa de ser mantida
 mas, no entanto, é a que mais reduz o tempo de compilação de um projeto. Ele
 realizou um experimento utilizando guardas de inclusão com e sem redundância,
 e obteve os resultados mostrados nas Tabelas \ref{tab:tabela_01} e 
\ref{tab:tabela_02};

\begin{table}
    \centering
    \begin{tabular}{ |c | c | c | c |}
    \hline
    Quantidade de Arquivos & SEM & COM & Sem Redundancia/Com Redundancia\\
    \hline
    1 & 0.2 & 0.2 & 1.0\\
    \hline
    2 & 0.2 & 0.2 & 1.0\\
    \hline
    4 & 0.3 & 0.3 & 1.0\\
    \hline
    8 & 0.5 & 0.3 & 1.67\\
    \hline
    16 & 0.7 & 0.4 & 1.75\\
    \hline
    32 & 1.5 & 1.1 & 3.0\\
    \hline
    64 & 0.2 & 0.2 & 1.0\\
    \hline
    128 & 25.9 & 3.5 & 74.0\\
    \hline
    256 & 126.5 & 13.6 & 9.3\\
    \hline
    512 & 702.3 & 61.6 & 11.4\\
    \hline
    1024 & 4378.5 & 306.6 & 14.28\\
    \hline
    \end{tabular}
    \caption {Amostra de Redundância com 10 headers por linha}
    \label{tab:tabela_01}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{ |c | c | c | c |}
    \hline
    Quantidade de Arquivos & SEM & COM & Sem Redundância/Com Redundância\\
    \hline
    1 & 0.2 & 0.2 & 1.0\\
    \hline
    2 & 0.2 & 0.2 & 1.0\\
    \hline
    4 & 0.4 & 0.3 & 1.33\\
    \hline
    8 & 0.7 & 0.4 & 1.75\\
    \hline
    16 & 1.7 & 0.5 & 3.4\\
    \hline
    32 & 5.8 & 0.9 & 6.44\\
    \hline
    64 & 22.1 & 2.0 & 11.05\\
    \hline
    128 & 89.5 & 5.2 & 17.21\\
    \hline
    256 & 376.5 & 17.1 & 22.02\\
    \hline
    512 & 1697.4 & 68.6 & 24.74\\
    \hline
    1024 & 8303.8 & 330.6 & 25.12\\
    \hline
    \end{tabular}
    \caption {Amostra de Redundância com 100 headers por linha }
    \label{tab:tabela_02}
\end{table}

\item Pragma Once

Pragma once é uma diretiva de pré-processamente que possui o objetivo de
 garantir que um arquivo será lido apenas uma vez: caso uma diretiva 
"\#include" seja utilizada novamente e o arquivo já foi incluído anteriormente,
 o mesmo não será aberto. No entanto, esta implementação se tornou obsoleta 
 na implementação do gcc \cite{gcc-pragma_once}. Os Códigos \ref{codigo_10} 
, \ref{codigo_11} e \ref{codigo_12} exemplificam o uso desta diretiva.



\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                                    Exemplo de arquivo c.hpp com guarda de 
                                         inclusão que utiliza \#pragma once},
                                                            label=codigo_10]
// c.hpp
/* pragma once indicar que o 
   arquivo c.hpp sera
   incluido apenas 1 vez */
#pragma once            
#include "a.hpp"
#include "b.hpp"

 // declaracoes de c.hpp

 ...

\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                                   Exemplo de arquivo a.hpp com guarda de 
                                    inclusão que utiliza \#pragma once},
                                                            label=codigo_11]
// a.hpp
#pragma once 

 // declaracoes de a.hpp

 ...

\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                                   Exemplo de arquivo b.hpp com guarda de 
                                      inclusão que utiliza \#pragma once},
                                                            label=codigo_12]
//b.hpp
#pragma once 

 // declaracoes de b.hpp

 ...

\end{lstlisting}

\end{enumerate}

\subsection{Forward Declaration}\label{forward_declaration_section}

Em C++, todas as entidades (variáveis, funções, classes, estruturas, uniões,
 etc) deve sem declaradas ou definidas antes de serem referenciadas. Definir
 uma classe antes dela ser utilizada não é possível quando as duas classes
 diferentes referenciam uma a outra, gerando uma referência cíclica
\cite{ref43}.

Considere um exemplo de duas classes, Doutor e Paciente,apresentadas no 
Código \ref{codigo_13}. Neste exemplo, a classe Doutor requer a 
declaração ou definição da classe Paciente, e a classe Paciente necessita 
de uma declaração ou de uma definição da classe Doutor. Desta forma, a 
compilação geraria um erro, pois antes de utilizar uma referência é 
necessário declarar ou definir esta referência.

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                        Implementação de classes Paciente e Doutor},
                                                     label=codigo_13]
// doutor_paciente.cpp

class Doutor {

  // implementacoes privadas
  private:

  /* a classe Doutor necessita saber que existe 
     a referencia para a classe Paciente */
  Paciente* p; 

  ...          

  // implementacoes publicas
  public:

  ...	

};

class Paciente {

 // implementacoes privadas
 private:

 /* a classe paciente necessita saber que 
 existe a classe Doutor, no entanto
 doutor so existe se souber da referencia
 de paciente */
 Doutor * d; 

 ...  

 // implementacoes publicas
 public:

 ...  

};

\end{lstlisting}

Para resolver este problema é preciso utilizar uma 
referência incompleta (\textit{"forward"}) da classe Doutor e da
 classe Paciente, conforme apresentado no Código \ref{codigo_14}. 

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
								Implementação de classes Paciente e
							 Doutor utilizando forward declaration},
                                                    label=codigo_14]
// forward declaration
class Doutor;   
class Paciente; 

class Doutor   {
  // implementacoes privadas
  private:

  /* a referencia incompleta de Paciente existe,
   entao Doutor pode armazenar a 
   referencia do paciente */

  Paciente* p; 
  
  ... 

  // implementacoes publicas
  public: 

  ...
 
};

class Paciente {
  // implementacoes privadas
  private:
	
  Doutor * d; 

  ... 
	
  // implementacoes publicas
  public: 

  ...

};

\end{lstlisting}

A declaração incompleta (\textit{forward declaration}) de uma classe somente podem
 ser utiliza em arquivos na forma de ponteiro (utilizando o operador "*")
 ou referência (utilizando o operador "\&"), pois estas não requerem uma
 definição de classe completa porque, em C++, é alocado uma quantidade fixa
 de armazenamento para estes tipos de variáveis \cite{ref43}.

Um exemplo incorreto de utilização de forward declaration seria utilizar
 um construtor da classe Doutor é mostrado no Código \ref{codigo_15}.


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                   Uso incorreto de Forward Declaration},
                                                label=codigo_15]
   // forward declaration
   class Doutor;

   // utilizacao da estrutura Doutor
   Doutor doutor();

\end{lstlisting}

Como já mencionado, qualquer entidade deve ser declarada ou definida antes
 de ser utilizada, então o caso acima é válido para funções, variáveis,
 estruturas e uniões, entre outros. A Tabela \ref{tab:tabela_03} mostra
 um exemplo de \textit{forward declaration} para alguns destes tipos
 de estruturas.

\begin{table}[h]
    \centering
    \begin{tabular}{ |c | c |}
    \hline
    Definição & Declaração\\
    \hline
    int x; & extern int x;\\
    \hline
    typedef struct Foo{int x;}; & typedef struct Foo;\\
    \hline
    class Foo { int x;public: Foo() ... }; & class Foo;\\
    \hline
    int Add( int x ,int  y) { return x + y; } & int Add(int x, int y);\\
    \hline
    union Foo { int x; char x; }Foo; & union Foo;\\
    \hline
    \end{tabular}
    \caption{Exemplos de \textit{forward declaration}}
    \label{tab:tabela_03}
\end{table}


Na linguagem C++ há uma separação entre  a implementação e a interface de
 classe\cite{ref44}.Na maioria dos casos, a definição de uma classe possui
 detalhes de sua implementação, como nos Código \ref{codigo_16} e \ref{codigo_17}.


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                          Arquivo declaração da classe Pessoa },
                                                label=codigo_16]

// pessoa.hpp   - declaracao da classe
#ifndef PESSOA_HPP
#define PESSOA_HPP

// conhecer detalhes de implementacao da string
#include <string>       
// conhecer detalhes de implementacao da Data
#include "data.hpp"     

class Pessoa{
public:

  Pessoa(std::string nome,Data data);
  std::string meu_nome() const;
  Data meu_aniversario() const;

private:
  // detalhes de implementacao na declaracao
  std::string nome;        

  // detalhes de implementacao na declaracao
  Data aniversario;        
};

#endif

\end{lstlisting}

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                               Arquivo definição da classe Pessoa},
                                                    label=codigo_17]
// pessoa.cpp implementacao da classe
#include "pessoa.hpp"

Pessoa::Pessoa(std::string nome, Data data)
        : nome(nome),aniversario(data)
{
}

std::string
Pessoa::meu_nome() const
{
        return nome;
}
Data
Pessoa::meu_aniversario() const
{
        return aniversario;
}

\end{lstlisting}    


Definir uma classe com detalhes de implementação em sua definição não é uma
 boa prática de programação, uma vez que ela não pode ser compilada sem
 conhecer as definições das classes utilizadas em sua implementação para
 realizar alocação de memória. Isso conduz à utilização da diretriz
 "\#include", gerando dependência entre arquivos\cite{ref44}.

Uma maneira de contornar este problema é utilizar uma forward declaration e a
 armazenar referências das classes, de modo que as definições das classes não
 possuam dependência uma das outras. Isto evita que definições de classes sejam
 modificadas com frequência e reduz a quantidade de recompilações devidas às
 dependência entre os  arquivos. Veja os Códigos \ref{codigo_18} 
e \ref{codigo_19}.


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                         	     Arquivo definição da classe Pessoa,       
                          utilizando \textit{forward declaration}},
                                                label=codigo_18]
// pessoa.hpp 
#ifndef PESSOA_HPP
#define PESSOA_HPP

// header para string forward declaration
#include <bits/stringfwd.h>    

// forward declaration
class Data;            

class Pessoa{
public:
        Pessoa(std::string& nome,Data *data);
        std::string& meu_nome() const;
        Data* meu_aniversario() const;

private:
// referencia para string
  std::string& nome;

// referencia para Data
  Data* aniversario;
};

#endif

\end{lstlisting}


\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                          Arquivo definição da classe Pessoa,       
                      utilizando \textit{forward declaration} },
                                                label=codigo_19]

// pessoa.cpp -  implementacao
#include "pessoa.hpp"
#include <string>

Pessoa::Pessoa(std::string& nome, Data* data)
        : nome(nome),aniversario(data)
{
}
std::string&
Pessoa::meu_nome() const
{
        return nome;
}
Data*
Pessoa::meu_aniversario() const
{
        return aniversario;
}

\end{lstlisting}


O Código \ref{codigo_18} foi feito o uso da diretiva \#include
 <bits/stringfwd.h>. Em C++  existem arquivos-cabeçalhos que possuem a
 implementação de forward declaration. A Tabela \ref{tab:tabela_04} lista 
 alguns forward declaration que podem ser utilizados em C++ segundo
 a gcc-gnu \cite{gcc-api}.

\begin{table}[h]
    \centering
	\begin{tabular}{ |l|p{10cm} | l|p{10cm} |}
	\hline
	Biblioteca & Alguns includes do header\\
	\hline

	\#include<bits/stringfwd.h> & std::string,

								 std::wstring,std::u16string, 

								 std::u32string;\\
	\hline
	\#include <iosfwd> & std::filebuf, std::fstream,
						std::ifstream, std::iostream,
						std::istream, std::ofstream,
						std::ostream, std::ostringstream,
						std::stringbuf,std::streambuf,
						entre outros;\\
	\hline
	\#include <bits/localefwd.h> & std:has\_facet, std::isalnum,
								  std::isalpha, std::iscntrl,
								  std::isdigit,std::isgraph,
								  std::islower, std::isprint,
								  std::ispunct,
								  std::isspace,std::issuper,
								  entre outros;\\
	\hline
	\#include <bits/algorithmfwd.h> & std::adjacent\_find,std::any\_of,
									 std::binary\_search, 
									 std::copy\_backward, std::copy\_if,
									 std::count\_if, std::count,
									 std::find\_end, std::find\_if,
									 entre outros.\\
	\hline
	\end{tabular}
	\caption {Tabela de Algumas \textit{forward 
			  declaration} padrões do c++}
    \label{tab:tabela_04}
\end{table}


\subsection{MakeFile}\label{Makefile_section}


Make é uma ferramenta utilizada para determinar automaticamente quais
 os trechos de código de um grande projeto precisam serem recompilados
 após alguma iteração de desenvolvimento. Esta ferramenta foi implementada
 por Richard Stallman e Roland McGrath. Desde a versão 3.76 até os dias de
 hoje vem sendo mantida por Paul D.Smith\cite{Lasca2}.O manual de utilização do makefile
 é disponibilizado no portal GNU \cite{ref45}.

Para utilizar a ferramenta make é necessário a criação de um arquivo chamado
 makefile, que contem as descrições de relações entre os arquivos em um projeto
 e comandos necessários para realizar as atualizações em cada arquivo\cite{Lasca2}.
 Depois de definir o arquivo makefile, utiliza a chamada de sistema apresentada 
no Codigo \ref{codigo_20}.

\begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                             Chamada de Sistema para executar o programa make},
				                                                label=codigo_20]
    $ make
\end{lstlisting}


O programa make realiza as devidas verificações nos códigos fontes e
 nos códigos objetos, e caso seja necessário recompilar um arquivo, o
 makefile contém as instruções necessárias para o tal procedimento
 \cite{ref46}.


\subsection{Estrutura básica de um arquivo makefile}

Arquivos makefile contém 5 tipos básicos de elementos: regras explicitas,
 regras implícitas, definição de variáveis, diretivas e comentários.

\begin{enumerate}

    \item Regras Explicitas: \
        conjunto de regras que informam quando e como refazer as construções
         de arquivos. Ela é definida pela estrutura apresentada no Codigo \ref{codigo_21}.


        \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
                                     			Regras explicitas Makefile},
                                                        label=codigo_21]

alvo ... : pre-requisitos ... 
    procedimentos
	...
ou 

alvo ... : pre-requisitos ... ; procedimentos
    procedimentos
    ...

        \end{lstlisting}


 O \textbf{alvo} é utilizado para nomear os artefatos que devem ser gerados pelo projeto.
 O alvo também pode ser utilizado para fazer a chamada de execução de um trecho
 específico do Makefile,  sendo passando como parâmetro na utilização do comando
 make.

 Os \textbf{pré-requisitos} são os endereços de arquivos utilizados como entrada para a 
criação do alvo. Este campo é opcional, pois podem existir instruções que não
 necessitam de arquivos de entrada, como por exemplo a instrução "clean”
 (tipicamente utilizada para remoção de todos os códigos objetos gerados a partir
 dos códigos do projeto) \cite{ref47}.

Os \textbf{procedimentos} são as ações que devem ser executadas a partir do comando make.
Este bloco pode conter mais de um comando em uma linha, ou  vários comandos em
 linhas separadas \cite{ref47}.

    \item Regras Implícias: \
 conjunto de regras que informam quando e como refazer uma classe de arquivos
 baseadas em seus nomes e padrões \cite{ref48}. Um exemplo de utilização de 
 padrões é apresentado no Código \ref{codigo_22} \cite{ref49}
        
    \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                          Exemplo de utilização de padrões no Makefile},
                                                        label=codigo_22]

# gerar  objetos ".o" utilizando arquivos ".c"
%.o : %.c
    procedimentos
    ...

    \end{lstlisting}


    \item Definição de Variáveis:\
 é uma linha que especifica um valor para uma variável que pode ser substituída no
 texto posteriormente \cite{ref43}. Veja o Código \ref{codigo_23} para um exemplo de 
definição de variável.

    \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                                     Definição de variavel e utilização},
                                                         label=codigo_23]
objetos = main.o command.o display.o files.o\
          search.o utils.o

clean:
    rm $(objetos)
    \end{lstlisting}


    \item Diretivas: \
são instruções que indicam ao make ações especiais a medida que é realizada a leitura do
 arquivo Makefile \cite{ref43}. Estas instruções podem ser:

    \begin{itemize}
        \item Realizar a leitura de um outro makefile, através da diretiva include, seguida do nome do arquivo.
        \item Utilizar ou ignorar parte do makefile.\cite{ref43} O Código \ref{codigo_24} ilustra o uso desta diretiva. 


    \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                             Exemplo Make file com diretiva condicional},
                                                         label=codigo_24]

ibs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
$(CC) -o foo $(objects) $(libs_for_gcc)
else
$(CC) -o foo $(objects) $(normal_libs)
endif

    \end{lstlisting}

    \begin{itemize}
        \item \textbf{ifeq:} Diretiva que começa a condicional e especifica a 
    condição. Ela contém 2 argumentos, separados por virgula e entre parêntesis.
     Caso os argumentos forem iguais as linhas entre o \textbf{ifeq} e o
     \textbf{else} serão executadas, caso contrário serão ignoradas\cite{ref50}.

        \item \textbf{else:} Diretiva que marca o início das instruções a serem 
    executadas caso a condição do \textbf{ifeq} falhe. Esta diretiva é opcional\cite{ref50}.

        \item \textbf{endif:} Diretiva que finaliza a condição. 
    Toda diretiva condicional condição deve ser terminada com endif\cite{ref50}.
    \end{itemize}

    \item Definir variáveis com mais de uma linha. Com a utilização da diretiva define
 e  da diretiva endef é possível realizar a definição de uma variável em mais
 de uma linha \cite{ref51}. O Código \ref{codigo_25} ilustra esta situação.

    \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={
						Exemplo Make file com definição de variavel em
													  multiplas linhas},
														label=codigo_25]
bar= "BAR"
define two-lines =
echo foo
echo $(bar)
endef
all:
$(two-lines)
    
    \end{lstlisting}


    \end{itemize}

    \item Comentários: \
Em arquivos Makefile a utilização de caractere "\#" em uma linha faz com
 que todos o carateres que o sucederem sejam ignorados. Caso seja necessário
 a utilização deste o caractere basta precedê-lo com o caractere "\\" 
(barra invertida)\cite{ref48}.

\end{enumerate}


\subsection{Padrões de um arquivo makefile para ferramentas GNU}

    
Tendo como referência o manual do GNU Make \footnote{
Manual GNU-Make: http://www.gnu.org/software/make/manual/make.pdf 
}, Seção 15.6, existem padrões que podem ser utilizados em arquivo
 makefile. Alguns dos mais comuns são:

\begin{enumerate}
    \item \textbf{all}: instrução executada por default pelo makefile, 
realiza as verificações do arquivos de código fonte e faz atualizações
 nos códigos objetos, se necessário;
    \item \textbf{install}: chama o make all e copia os arquivos 
executáveis, bibliotecas, e os demais artefatos do projeto para os 
locais adequados, de acordo com as necessiddades do projeto;
    \item \textbf{uninstall}: deleta todos os arquivos copiados 
pelo comando make install;
    \item \textbf{clean}: deleta todos os arquivos e diretórios 
criados na construção do programa final.
    \item \textbf{distclean}: remover os arquivos que foram gerados
 por algum comando make file, seja na configuração, seja na
 construção de um programa.
    \item \textbf{info}: gera um arquivo de informações sobre o programa.
    \item \textbf{dist}: gera um arquivo tar cujo nome contém a versão e
o nome do projeto e  que inclui  todo o conteúdo do diretório atual.
    \item \textbf{check}: gera o programa  e realiza testes. 
    \item \textbf{installcheck}: gera o programa, instala e realiza testes.
    \item \textbf{installdirs}: cria  os diretórios onde os arquivos devem ser instalados.
\end{enumerate}


\subsection{Executando makefile}

Depois de gerado o arquivo makefile utilizando as regras descritas nas seções anteriores,
 o comando make pode ser utilizado para executar as regras descritas.
O comando make pode ser utilizado como mostrado no Codigo \ref{codigo_26} e conforme apresentado na Tabela \ref{tab:tabela_05}.


    \begin{lstlisting}[language=C++,frame=single,captionpos=b,caption={ 
                                     Definição de variavel e utilização},
                                                         label=codigo_26]
    
        $ make [opcoes] ... [Alvo]

    \end{lstlisting}


\textbf{Alvo}: é a instrução que será executada pelo makefile. 
A omissão deste parâmetro leva a execução do alvo "all".
    
\textbf{Opções}: são flags de controle utilizadas pelo utilitario make.
 Exemplos de flags estão definidas na Tabela \ref{tab:tabela_05}:

\begin{table}[h]
    \centering
    \begin{tabular}{ | l|p{10cm} | l|p{10cm} |}
    \hline
    Flag & Descrição\\
    \hline
    -C dir , --directory=dir & Modifica o diretório antes de fazer a leitura do makefile\\
    \hline
    -f file    ,     --file=file     ,  --makefile=FILE & Realiza a leitura de um makefile especifico\\
    \hline
    -i   ,     --ignore-errors & Ignora erros na reconstrução de arquivos\\
    \hline
    -I dir   ,   --include-dir=dir & Especifica o diretório que inclue os makefiles\\
    \hline
    -j [jobs]  , --jobs[=jobs] & Especifica a quantidade de threads
                                 que podem ser executadas em paralelo. 
                                 Caso não seja passado a quantidade de
                                 threads ele não terá limites na criação
                                 de threads.\\
    \hline
    \end{tabular}
    \caption {Exemplos de flags que podem ser utilizadas no make}
    \label{tab:tabela_05}
\end{table}

    * Palavras entre "[" e "]" são opcionais.
