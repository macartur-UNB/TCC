\begin{apendicesenv}

\partapendices

\chapter{Script Aplicado ao Ambiente}

\section{Gerador de Codigo para Benchmark}

\subsection{Guardas de Inclusão Externa mais Pragma Once}
\begin{lstlisting}[language=Python, caption={
     Script Guardas de Inclusão Externa mais pragma once},
                  label=script_external_pragma_include]

# external_pragma.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./external_pragma/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#pragma once\nconst int int{0} = {0};"""
end_of_main_file = "int main() {\n}\n"
header = """#ifndef H{0}_HPP
#define H{0}_HPP
#include "{0}.hpp"
#endif
"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)
        main.write("\n")

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
                                                                                  
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)      

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas de Inclusão Externa}
\begin{lstlisting}[language=Python,caption={
            Script Guardas de Inclusão Externa },
                   label=script_external_include]
                   
                   
# external.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./external/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """const int int{0} = {0};"""
end_of_main_file = "int main() {\n}\n"
header = """#ifndef H{0}_HPP
#define H{0}_HPP
#include "{0}.hpp"
#endif
"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)
        main.write("\n")

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()

def copy_util_files():
    command = "cp util/* "
    command += folder
    system(command)
    

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas de Inclusão Interna}
\begin{lstlisting}[language=Python,caption={
              Script Guardas de Inclusão Interna},
                     label=script_intenal_include]
                     
# guard_only.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./guard-only/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#ifndef H{0}_HPP
#define H{0}_HPP
const int int{0} = {0};
#endif
"""

end_of_main_file = "int main() {\n}\n"
header = "#include \"{0}.h\"\n"

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)
        main.write("\n")

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
                                                                                  
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)      

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas de Inclusão Interna primeiro que o Pragma Once}
\begin{lstlisting}[language=Python, caption={
Script Guardas de Inclusão Interna primeiro que \textit{Pragma Once}},
                   label=script_guards_pragma_include]
                   
# guards_pragma.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./guards-pragma/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#ifndef H{0}_HPP
#define H{0}_HPP
#pragma once
const int int{0} = {0};
#endif
"""

end_of_main_file = "int main() {\n}"
header = """#include "{0}.hpp"\n"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)                                                              
                    

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas de Inclusão com Pragma Once primeiro que Inclusão Interna}
\begin{lstlisting}[language=Python, caption={
    Script \textit{Pragma Once} primeiro que Guardas de Inclusão Interna},label=script_pragma_guards_include]
    
# pragma_guards.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./pragma-guards/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#pragma once
#ifndef H{0}_HPP
#define H{0}_HPP
const int int{0} = {0};
#endif
"""

end_of_main_file = "int main() {\n}"
header = """#include "{0}.h"\n"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)                                                              

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas Inclusão com Pragma Once}
\begin{lstlisting}[language=Python, caption={
                     Script Pragma Once},
             label=script_pragma_once_include]
             
# pragma_only.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./pragma-only/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#pragma once
const int int{0} = {0};
"""

end_of_main_file = "int main() {\n}"
header = """#include "{0}.h"\n"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)                                                              
                      

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Guardas de Inclusão com Redundância}
\begin{lstlisting}[language=Python,caption={
     Script Redundância de Guardas de Inclusão},
                 label=script_redundante_include]
                 
# redundante.py
from os import mkdir
from os import path
from os import system

number_of_files = 10**4
number_of_includes = 3

folder =  "./redundant/"

include_directory = folder+"include"
include_path = folder+"include/{0}.hpp"
path_main_file = folder+"main.cpp"

content_of_include = """#ifndef H{0}_HPP
#define H{0}_HPP
const int int{0} = {0};
#endif"""
end_of_main_file = "int main() {\n}\n"
header = """#ifndef H{0}_HPP
#define H{0}_HPP
#include "{0}.hpp"
#endif
"""

def verify_directory(path_name):
    if not path.exists(path_name):
        mkdir(path_name)

def create_include_file(path,content):
    f =  open(path,"w+")
    f.write (content)
    f.close()

def create_includes():
    #create directory
    # create all files
    for number in range(0,number_of_files):
        path = include_path.format(str(number))
        content = content_of_include.format(str(number))
        create_include_file(path,content)
    
def create_main_file():
    #open main.cpp
    main = open(path_main_file,"w+")

    #write includes 3 times
    for number in range(0,number_of_files):
        for x in range(0,number_of_includes):
            content = header.format(str(number))
            main.write(content)
        main.write("\n")

    #write end of file
    main.write(end_of_main_file)

    #close main.cpp
    main.close()
def copy_util_files():                                                           
    command = "cp util/* "                                                       
    command += folder                                                            
    system(command)                                                              
                    

def main():
    verify_directory(folder)
    verify_directory(include_directory)
    create_includes()
    create_main_file()
    copy_util_files()

if __name__ == "__main__":
    main()

\end{lstlisting}


\chapter{Script Aplicado a Projeto}
\section{Recompilação de Projetos}
\begin{lstlisting}[language=Python, caption={Script de Recompilações},
                  label=script_recompilacoes]

        # *-* encoding: utf8 *-*
        from datetime import datetime
        from os import getcwd, chdir, makedirs, system
        from os.path import exists
        from yaml import load

        # common variables
        MAX_TIMES = 10
        current_dir = getcwd()
        output = current_dir+"/output/"
        config_file = current_dir+"/projects.yaml"

        def make_directories():
            if(not exists(output)):
                makedirs(output)

        def write_result(message, file_name):
            message += "\n"
            make_directories()
            _file = open(output+file_name, "a+")
            _file.write(message)
            _file.close()


        def change_to(directory):
            path = current_dir+"/"+directory
            chdir(path)
            print("Changed to {}".format(directory))


        def compile_project(command, project_debug):
            if not project_debug:
                command += " > /dev/null 2> /dev/null"

            system(command)


        def clean_projects(command, project_debug):
            if not project_debug:
                command += " > /dev/null 2> /dev/null"

            system(command)


        def wait_time():
            command = "sleep 1"
            system(command)


        def all_project(file_name):
            with open(file_name, 'r') as stream:
                content = load(stream)
            return content


        def set_branch(branch_name):
            command = "git checkout {}".format(branch_name)
            system(command)

        def exec_command(command):
            print "Using command %s"%(command)
            system(command)


        projects = all_project(config_file)

        if not projects:
            print("Need create a projects.yaml with projects attributes")

        else:
            for project_name, project in projects.items():
                print("Compiling [ {} ]".format(project_name))

                change_to(project['directory']+"/"+project['makefile'])

                for branch in project['branchs'] :
                    set_branch(branch['name'])

                    if branch['pre-command']:
                        for command in branch['pre-command']:
                            exec_command(command['command'])

                    message = "Branch [{}][{}]:".format(branch['name'],branch['description'])

                    write_result(message,project_name)

                    for times in range(0, MAX_TIMES):

                        clean_projects(branch['clean'], project['debug'])
                        wait_time()

                        start_time = datetime.now()
                        compile_project(branch['compile'], project['debug'])
                        end_time = datetime.now()

                        elapsed = end_time - start_time

                        text = "[{}/{}] : {:>4} ms".format(times+1, MAX_TIMES,
                                                              elapsed.total_seconds())

                        if not project['debug']:
                            print(text)

                        write_result(text, project_name)

                    write_result("*"*40+"", project_name)

                    if branch['pos-command']:
                        for command in branch['pos-command']:
                            exec_command(command['command'])

            print("Finished the result was saved in output folder")
\end{lstlisting}

\subsection{Template yaml para compilação de projetos}
\begin{lstlisting}[language=ruby, caption={Template para execução do Script de Recompilações},
                  label=template_para_script_recompilacoes]
    <project name>:
    directory:          <directory to project>
    makefile:           <path to make file into directory>
    debug:              <flag to see the project compilling>
    branchs:
       - name:          <branch to compile>
         description:   <little description>
         compile:        <line to compile the project>
         clean:            <line to clean the object compiled>
         pre-command:
              - command: <command executed before compile>
              - command: <command executed before compile>
              - command: <command executed before compile>
         pos-command:
              - command: <command executed after compile>
              - command: <command executed after compile>
              - command: <command executed after compile>
\end{lstlisting}

\end{apendicesenv}
